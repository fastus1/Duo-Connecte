---
phase: 03-documentation-data
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/db-reset.ts
  - docs/extension-guide.md
  - package.json
autonomous: true

must_haves:
  truths:
    - "Running db:reset clears user data but preserves schema"
    - "Developer can learn how to add a new page from extension guide"
    - "Developer can learn how to add an API route from extension guide"
  artifacts:
    - path: "scripts/db-reset.ts"
      provides: "Database reset functionality"
      min_lines: 40
      contains: ["delete", "loginAttempts", "users"]
    - path: "docs/extension-guide.md"
      provides: "Extension documentation"
      min_lines: 80
      contains: ["## Adding a New Page", "## Adding an API Route"]
  key_links:
    - from: "package.json"
      to: "scripts/db-reset.ts"
      via: "npm script"
      pattern: "db:reset"
---

<objective>
Create database reset script and extension guide for developers.

Purpose: Developers need clean-slate tooling and guidance to extend the template.
Output: scripts/db-reset.ts for database reset, docs/extension-guide.md for extending the template.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-documentation-data/03-RESEARCH.md
@shared/schema.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database reset script</name>
  <files>scripts/db-reset.ts, package.json</files>
  <action>
1. Create scripts/ directory if needed

2. Create scripts/db-reset.ts:

```typescript
/**
 * Database Reset Script
 *
 * Clears all user data while preserving schema structure.
 * Use this for clean-slate deployments or testing.
 *
 * Run: npm run db:reset
 *
 * CAUTION: This permanently deletes all user data!
 */

import { drizzle } from 'drizzle-orm/neon-serverless';
import { Pool, neonConfig } from '@neondatabase/serverless';
import ws from 'ws';
import * as schema from '../shared/schema';

neonConfig.webSocketConstructor = ws;

async function resetDatabase() {
  const databaseUrl = process.env.DATABASE_URL;

  if (!databaseUrl) {
    console.error('ERROR: DATABASE_URL environment variable not set');
    process.exit(1);
  }

  // Safety check for production
  if (process.env.NODE_ENV === 'production') {
    console.error('ERROR: Cannot reset database in production mode');
    console.error('Set NODE_ENV to development or remove the check if intentional');
    process.exit(1);
  }

  const pool = new Pool({ connectionString: databaseUrl });
  const db = drizzle({ client: pool, schema });

  console.log('Starting database reset...\n');

  try {
    // Delete in order respecting foreign key constraints
    // (login_attempts references users via userId)

    console.log('Deleting login_attempts...');
    await db.delete(schema.loginAttempts);

    console.log('Deleting support_tickets...');
    await db.delete(schema.supportTickets);

    console.log('Deleting feedbacks...');
    await db.delete(schema.feedbacks);

    console.log('Deleting paid_members...');
    await db.delete(schema.paidMembers);

    console.log('Deleting users...');
    await db.delete(schema.users);

    // Reset app_config to defaults (don't delete - app needs it)
    console.log('Resetting app_config to defaults...');
    await db.update(schema.appConfig).set({
      requireCircleDomain: true,
      requireCircleLogin: true,
      requirePaywall: false,
      requirePin: true,
      paywallPurchaseUrl: '',
      paywallInfoUrl: '',
      paywallTitle: 'Acces Reserve',
      paywallMessage: 'Cette application est reservee aux membres ayant souscrit.',
      webhookAppUrl: '',
      environment: 'development',
      updatedAt: new Date(),
    });

    console.log('\n✓ Database reset complete!');
    console.log('  - All user data cleared');
    console.log('  - Schema preserved');
    console.log('  - App config reset to defaults');

  } catch (error) {
    console.error('Reset failed:', error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

resetDatabase();
```

3. Add npm script to package.json:
   Add to "scripts" section: `"db:reset": "tsx scripts/db-reset.ts"`
  </action>
  <verify>
    - Directory exists: `ls scripts/`
    - Script exists: `ls scripts/db-reset.ts`
    - Script contains delete operations: `grep "delete" scripts/db-reset.ts`
    - Script handles FK order (loginAttempts before users): `grep -A5 "login_attempts" scripts/db-reset.ts`
    - package.json has script: `grep "db:reset" package.json`
  </verify>
  <done>scripts/db-reset.ts exists, deletes data in FK-safe order, resets config, npm run db:reset available</done>
</task>

<task type="auto">
  <name>Task 2: Create extension guide</name>
  <files>docs/extension-guide.md</files>
  <action>
Create docs/extension-guide.md with practical examples:

```markdown
# Extension Guide

How to extend the Circle App Template with new features.

## Adding a New Page

### Step 1: Create the Page Component

Create a new file in `client/src/pages/`:

```tsx
// client/src/pages/MyFeature.tsx
export default function MyFeature() {
  return (
    <div className="container mx-auto p-6">
      <h1 className="text-2xl font-bold mb-4">My Feature</h1>
      <p>Your content here.</p>
    </div>
  );
}
```

### Step 2: Add the Route

In `client/src/App.tsx`, import your component and add a route:

```tsx
import MyFeature from "@/pages/MyFeature";

// Inside SessionRouter's Switch component:
<Route path="/my-feature" component={MyFeature} />
```

### Step 3: Protected vs Public

By default, all routes require authentication. To make a page public:

1. Open `client/src/components/AccessGate.tsx`
2. Find the public paths array
3. Add your path: `'/my-feature'`

## Adding an API Route

### Step 1: Create the Route File

Create a new file in `server/routes/`:

```typescript
// server/routes/myfeature.ts
import { Router, Request, Response } from "express";
import { storage } from "../storage";
import { requireAuth } from "../middleware";

const router = Router();

// GET /api/myfeature/items - Get all items
router.get('/items', requireAuth, async (req: Request, res: Response) => {
  try {
    // Your logic here - use storage for DB access
    const items = []; // Replace with actual query
    return res.json({ items });
  } catch (error) {
    console.error('Error fetching items:', error);
    return res.status(500).json({ error: 'Server error' });
  }
});

// POST /api/myfeature/items - Create an item
router.post('/items', requireAuth, async (req: Request, res: Response) => {
  try {
    const { name } = req.body;
    if (!name) {
      return res.status(400).json({ error: 'Name required' });
    }
    // Create item in database
    return res.status(201).json({ success: true });
  } catch (error) {
    console.error('Error creating item:', error);
    return res.status(500).json({ error: 'Server error' });
  }
});

export default router;
```

### Step 2: Register the Route

In `server/routes/index.ts`, import and register:

```typescript
import myfeatureRouter from "./myfeature";

export function registerModularRoutes(app: Express): void {
  // ... existing routes
  app.use('/api/myfeature', myfeatureRouter);
}
```

## Adding a Database Table

### Step 1: Define the Schema

In `shared/schema.ts`, add your table:

```typescript
export const myItems = pgTable("my_items", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: text("name").notNull(),
  userId: varchar("user_id").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertMyItemSchema = createInsertSchema(myItems).omit({
  id: true,
  createdAt: true,
});

export type InsertMyItem = z.infer<typeof insertMyItemSchema>;
export type MyItem = typeof myItems.$inferSelect;
```

### Step 2: Push the Schema

Run the migration:

```bash
npm run db:push
```

### Step 3: Add Storage Methods

In `server/storage.ts`, add methods to the IStorage interface and DatabaseStorage class.

## Common Patterns

### Using the Storage Layer

Always use the storage interface for database operations:

```typescript
import { storage } from "../storage";

// Get user
const user = await storage.getUser(userId);

// Create record
await storage.createSomething(data);
```

### Authentication Middleware

Use `requireAuth` for protected routes:

```typescript
import { requireAuth, requireAdmin } from "../middleware";

router.get('/protected', requireAuth, handler);      // Any logged-in user
router.get('/admin-only', requireAdmin, handler);    // Admin users only
```

### Error Handling

Follow the existing pattern:

```typescript
try {
  // Your logic
  return res.json({ data });
} catch (error) {
  console.error('Context:', error);
  return res.status(500).json({ error: 'User-friendly message' });
}
```

## Project Structure Reference

```
client/src/
├── pages/           # Page components (add new pages here)
├── components/      # Reusable UI components
├── contexts/        # React contexts (auth, session)
├── hooks/           # Custom hooks
└── lib/             # Utilities

server/
├── routes/          # API routes (add new routes here)
├── middleware.ts    # Auth middleware
└── storage.ts       # Database access layer

shared/
└── schema.ts        # Database schema (add tables here)
```

## Further Reading

- [ARCHITECTURE.md](../ARCHITECTURE.md) - Detailed architecture documentation (French)
- [Drizzle ORM Docs](https://orm.drizzle.team/) - Database ORM reference
- [wouter](https://github.com/molefrog/wouter) - React router used
```

Note: Escape backticks in code blocks with backslash when writing to file.
  </action>
  <verify>
    - File exists: `ls docs/extension-guide.md`
    - Contains page guide: `grep "Adding a New Page" docs/extension-guide.md`
    - Contains API guide: `grep "Adding an API Route" docs/extension-guide.md`
    - Contains DB guide: `grep "Adding a Database Table" docs/extension-guide.md`
    - Line count: `wc -l docs/extension-guide.md` shows 80+
  </verify>
  <done>docs/extension-guide.md exists with complete examples for pages, API routes, and database tables</done>
</task>

</tasks>

<verification>
1. scripts/db-reset.ts exists and is syntactically valid
2. Reset script deletes tables in correct FK order (loginAttempts before users)
3. Reset script preserves app_config (updates, doesn't delete)
4. package.json has db:reset script
5. docs/extension-guide.md has examples for pages, API routes, DB tables
6. Guide references actual project files and patterns
</verification>

<success_criteria>
- `npm run db:reset` command available (dry-run check with script existence)
- Extension guide has concrete code examples
- Guide explains protected vs public routes
- Guide covers storage layer usage pattern
</success_criteria>

<output>
After completion, create `.planning/phases/03-documentation-data/03-02-SUMMARY.md`
</output>
